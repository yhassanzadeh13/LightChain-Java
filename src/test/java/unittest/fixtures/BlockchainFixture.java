package unittest.fixtures;

import java.util.ArrayList;
import java.util.Random;

import model.crypto.Signature;
import model.lightchain.*;
import protocol.Parameters;
import protocol.assigner.LightChainValidatorAssigner;
import protocol.block.BlockValidator;
import protocol.transaction.TransactionValidator;
import state.Snapshot;
import state.table.TableState;

/**
 * Creates a chain of validated blocks.
 */
public class BlockchainFixture {
  private final static Random rand = new Random();

  /**
   * It then creates a genesis empty validated block, and keeps extending the chain of blocks with new validated blocks
   * till it creates the specified number of blocks.
   * Each block points to the previous block as its previousBlockId.
   * Each block contains random number of transactions between man and max parameters.
   * Each transaction gets validated by running the assignment on that as well as the transaction validator, signing the
   * validation certification on behalf of its validators using their private keys, and including it in a block.
   * Each block has a randomly chosen proposer, goes through validation and gets validation signature by its validators.
   *
   * @param rootSnapshot Root snapshot for genesis block that contains at least as many validator threshold as
   *                     protocol parameter says. Each account is staked, and has enough balance to make a transaction
   *                     per block (though it may not really do that).
   * @param blockNum     number of blocks generated by this chain.
   * @return chain of validated blocks.
   * @throws IllegalStateException if any block or transaction fails validation.
   */
  public static ArrayList<ValidatedBlock> newValidChain(Snapshot rootSnapshot, int blockNum)
      throws IllegalStateException {
    ArrayList<ValidatedBlock> chain = new ArrayList<>();
    ArrayList<Account> accounts = rootSnapshot.all();
    Signature[] certificates = new Signature[Parameters.VALIDATOR_THRESHOLD];

    for (int i = 0; i < certificates.length; i++) {
      certificates[i] = SignatureFixture.newSignatureFixture(accounts.get(i).getIdentifier());
    }
    ValidatedBlock genesisBlock = new ValidatedBlock(null, null, null, null, null);
    chain.add(genesisBlock);
    Identifier prevBlockId = genesisBlock.id();
    TableState tableState = new TableState();
    tableState.addSnapshot(genesisBlock.id(), rootSnapshot);

    for (int i = 0; i < blockNum; i++) {
      int transactionNumber = rand.nextInt(Parameters.MAX_TRANSACTIONS_NUM - Parameters.MIN_TRANSACTIONS_NUM) + Parameters.MIN_TRANSACTIONS_NUM;
      ValidatedTransaction[] transactions = new ValidatedTransaction[transactionNumber];
      for (int j = 0; j < transactionNumber; j++) {
        transactions[j] = ValidatedTransactionFixture.newValidatedTransaction();
        LightChainValidatorAssigner assigner = new LightChainValidatorAssigner();
        Assignment assignment = assigner.assign(transactions[j].id(), rootSnapshot, (short) Parameters.VALIDATOR_THRESHOLD);
        // TODO: run the assignment on the transaction as well.
        TransactionValidator transactionValidator = new TransactionValidator(tableState);
        if(!transactionValidator.isCorrect(transactions[j]) ||
          !transactionValidator.isSound(transactions[j]) ||
          !transactionValidator.isAuthenticated(transactions[j]) ||
          !transactionValidator.senderHasEnoughBalance(transactions[j])) {
          throw new IllegalStateException("Transaction failed validation.");
        }
      }
      Identifier proposer = IdentifierFixture.newIdentifier();
      ValidatedBlock block = new ValidatedBlock(prevBlockId, proposer, transactions, null, certificates);
      BlockValidator blockValidator = new BlockValidator(tableState);
      if(!blockValidator.allTransactionsSound(block) ||
        !blockValidator.allTransactionsValidated(block) ||
        !blockValidator.isAuthenticated(block) ||
        !blockValidator.isConsistent(block) ||
        !blockValidator.isCorrect(block) ||
        !blockValidator.noDuplicateSender(block) ||
        !blockValidator.proposerHasEnoughStake(block)) {
        throw new IllegalStateException("Block failed validation");
      }
      chain.add(block);
    }
    return chain;
  }
}
