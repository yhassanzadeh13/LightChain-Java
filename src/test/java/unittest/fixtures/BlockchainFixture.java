package unittest.fixtures;

import java.util.ArrayList;
import java.util.Random;

import model.crypto.Signature;
import model.lightchain.*;
import protocol.Parameters;
import protocol.assigner.LightChainValidatorAssigner;
import protocol.block.BlockValidator;
import protocol.transaction.TransactionValidator;
import state.Snapshot;
import state.table.TableState;

/**
 * Creates a chain of validated blocks.
 */
public class BlockchainFixture {
  private final static Random rand = new Random();

  /**
   * It then creates a genesis empty validated block, and keeps extending the chain of blocks with new validated blocks
   * till it creates the specified number of blocks.
   * Each block points to the previous block as its previousBlockId.
   * Each block contains random number of transactions between man and max parameters.
   * Each transaction gets validated by running the assignment on that as well as the transaction validator, signing the
   * validation certification on behalf of its validators using their private keys, and including it in a block.
   * Each block has a randomly chosen proposer, goes through validation and gets validation signature by its validators.
   *
   * @param rootSnapshot Root snapshot for genesis block that contains at least as many validator threshold as
   *                     protocol parameter says. Each account is staked, and has enough balance to make a transaction
   *                     per block (though it may not really do that).
   * @param blockNum     number of blocks generated by this chain.
   * @return chain of validated blocks.
   * @throws IllegalStateException if any block or transaction fails validation.
   */
  public static ArrayList<ValidatedBlock> newValidChain(Snapshot rootSnapshot, int blockNum)
      throws IllegalStateException {
    ArrayList<ValidatedBlock> chain = new ArrayList<>();
    ArrayList<Account> accounts = rootSnapshot.all();
    Signature[] certificates = new Signature[Parameters.VALIDATOR_THRESHOLD];

    for (int i = 0; i < certificates.length; i++) {
      certificates[i] = SignatureFixture.newSignatureFixture(accounts.get(i).getIdentifier());
    }
    ValidatedTransaction[] emptyTransactions = new ValidatedTransaction[0];
    Signature[] emptyCertificates = new Signature[0];
    Identifier prevBlockId = rootSnapshot.getReferenceBlockId();
    TableState tableState = new TableState();
    tableState.addSnapshot(prevBlockId, rootSnapshot);


    for (int i = 0; i < blockNum; i++) {
      int transactionNumber = rand.nextInt(Parameters.MAX_TRANSACTIONS_NUM - Parameters.MIN_TRANSACTIONS_NUM) + Parameters.MIN_TRANSACTIONS_NUM;
      Transaction[] transactions = new Transaction[transactionNumber];
      ValidatedTransaction[] validatedTransactions = new ValidatedTransaction[transactionNumber];
      for (int j = 0; j < transactionNumber; j++) {
        Identifier sender = accounts.get(rand.nextInt(accounts.size())).getIdentifier();
        Identifier receiver = accounts.get(rand.nextInt(accounts.size())).getIdentifier();
        Transaction tx = new Transaction(prevBlockId, sender, receiver, rand.nextDouble()*1000);
        LightChainValidatorAssigner assigner = new LightChainValidatorAssigner();
        Assignment assignment = assigner.assign(tx.id(), rootSnapshot, (short) Parameters.VALIDATOR_THRESHOLD);
        // TODO: run the assignment on the transactions.
        TransactionValidator transactionValidator = new TransactionValidator(tableState);
        if(!transactionValidator.isCorrect(tx) ||
            !transactionValidator.isSound(tx) ||
            !transactionValidator.isAuthenticated(tx) ||
            !transactionValidator.senderHasEnoughBalance(tx)) {
          throw new IllegalStateException("Transaction failed validation.");
        } else {
          validatedTransactions[j] = new ValidatedTransaction(tx.getReferenceBlockId(), tx.getSender(), tx.getReceiver(), tx.getAmount(), certificates);
        }
      }
      Identifier proposer = IdentifierFixture.newIdentifier();
      ValidatedBlock block = new ValidatedBlock(prevBlockId, proposer, validatedTransactions, null, certificates);
      BlockValidator blockValidator = new BlockValidator(tableState);
      if(!blockValidator.allTransactionsSound(block) ||
        !blockValidator.allTransactionsValidated(block) ||
        !blockValidator.isAuthenticated(block) ||
        !blockValidator.isConsistent(block) ||
        !blockValidator.isCorrect(block) ||
        !blockValidator.noDuplicateSender(block) ||
        !blockValidator.proposerHasEnoughStake(block)) {
        throw new IllegalStateException("Block failed validation");
      }
      chain.add(block);
    }
    return chain;
  }
}
